<template:meta default-text-matching="regex"/>
<template:switch-prioritized>
   <DIV t:condition="matches(@id, 'hitlist|speed_result_list_')">
    <DIV t:condition="@class=('box', 'trefferbox')">
      {nextPage := ()}
      <DIV class="box-header">
        <DIV t:condition="tokenize(@class, ' ') = ('box-right','pagination')">
        <span class="selectedlink" t:condition="not(contains(text(), '&#171;'))"/>
        <a>{nextPage:=if (contains(@href, "javascript:")) then 
              let $args := extract(@href, "\( *([0-9]+) *, *([0-9]+) *\)", (1,2) )
              return x"speedHitList.do?methodToCall=refineHitList&speedHitlistUrl=speedHitList.do&newMemorizeListName=&databaseId={$args[1]}&dbIdentifier={$args[1]}&pos={$args[2]}"
            else @href }</a>
        </DIV>
        <H2>{search-result-count := extract(., "[0-9]+")}</h2>
      </DIV>?
      
      
      <TABLE class="data">
        <TR>
        <TD t:condition="@style or @class"> <!-- condition to skip image column -->
        {book := {"orderable": 0}, hasZ3988 := false()}
        <!--{book := {"orderable": .//a[contains(., 'vormerk') or contains(., 'bestell')]}, 
         if ($book.orderable) then (book.order0 := $book.orderable/@href, book.orderTitle :=  $book.orderable) else (), 
         hasZ3988 := false()}-->
        <span class="Z3988">{hasZ3988 := true(),
        for $entry in tokenize(@title, "&amp") return 
           if (starts-with($entry, "rft.au=")) then book.author :=               uri-decode(substring-after($entry, "="))
           else if (starts-with($entry, "rft.isbn=")) then book.isbn :=          uri-decode(substring-after($entry, "="))
           else if (starts-with($entry, "rft.pub=")) then book.publisher :=      uri-decode(substring-after($entry, "="))
           else if (starts-with($entry, "rft.date=")) then book.year :=          uri-decode(substring-after($entry, "="))
           else if (starts-with($entry, "rft.atitle=") or starts-with($entry, "rft.btitle=") (:or starts-with($entry, "rft.tpages=") :)) then 
             book.title := concat($book.title, " ", uri-decode(substring-after($entry, "=")))
           else if (starts-with($entry, "rft_id=")) then book.home-url :=        uri-decode(substring-after($entry, "="))
           else ()      
        }</span>?
                    
        <A t:condition="contains(@href, 'singleHit')">{book._detail-url:=@href, if (not($hasZ3988) or $book.title = "") then book.title := (if (node-name(..) eq "div") then .. else .) else ()}</A>
        <t:if test="not($hasZ3988)">
          {if (exists($book.title!following-sibling::comment()[contains(., "Autor")])) then (
              $book.year := normalize-space(text()),  (: special output in winterthur :)
              $book.author := $book.title!following-sibling::br[2]/preceding-sibling::text()[1]  (: use preceding instead following to skip over comment :)
            ) else 
              book.author := normalize-space(text())
          }
          <strong class="c2">Band<t:s>
            temp := ./following-sibling::text()[1],
            book.subTitle := replace($temp, "\( *[0-9]+ *\)", ""), 
            book.year := extract($temp, "([0-9]{4})[. )]", 1)
          </t:s></strong>?
          <t:s>          
          typeswitch ($book.title) 
            case node() return
              if ($book.author = "" and not($book.subTitle) and exists($book.title/following-sibling::br[1])) then (
                brs := if ($book.title/following-sibling::comment()[contains(., "Zusatz HST")]) then   
                               (: for chemnitz brs[1] would be additional title data:)
                         ($book.title/following-sibling::comment()[contains(., "Zusatz HST")])[last()]/following-sibling::br/following-sibling::text()[1]
                       else $book.title/following-sibling::br/following-sibling::text()[1], 
                if (matches($brs[1], "[0-9]{2,4}")) then brs := ("", $brs) else (),
                if (normalize-space($brs[1])) then book.author :=  $brs[1] else (
                  let $split := extract(normalize-space($book.title/following-sibling::text()[1]), "(.*?)(\.[  \t\n\r]*)?-[  \t\n\r]*([0-9]+)",(1,3)) 
                  return if ($split[1]) then (
                    $book.author := $split[1],
                    $book.year := $split[2]
                  ) else ()),
                if (($book.author = "von" or $book.author = "") 
                     and (typeswitch ($brs[1]) case node() return $brs[1]/following-sibling::a and ($brs[1]/following-sibling::a)[1] &lt;&lt; $brs[2]  
                                              default return false()
                     )) then book.author := $brs[1]/following-sibling::a[1] 
                else if (matches($book.author, "^(ausleihbar|(entliehen|bestellbar).*)$")) then book.author := ""  (: pulheim :)
                else (),
                if (matches($brs[2], "[0-9]{2}")) then book.year := $brs[2] else ()
                (:,book.id := $brs[3] this can also be more title data (e.g. basel):)
              ) else () 
            default return ()
          </t:s>
        </t:if>
        
       <!-- <SPAN class="textgruen">{$book.availability}</SPAN>? who cares?-->
        </TD>
        </TR>*
      </TABLE>
    </DIV>    
  </DIV>

  <div id="main">
    <a>Titeldaten|mehr zum Titel<t:s>
      singleBookResult:= if (starts-with(@href, "#")) then $url else @href, 
      search-result-count:=1</t:s></a>
    <div t:condition="@id=('tab-content', 'detailsTabs-titleinfo')">
      <template:switch>
        <table class="data"/>
        <table class="data2"/>
        <table t:condition="@class=('fulltitle','titleinfo')"/>
      </template:switch>
    </div>
  </div>
  
  <h2>Ihre Suche erzielte keine Treffer</h2>   
  
  <form>
    <input type="hidden" name="speedHitlistUrl" value="speedHitList.do" /> 
    <script>
    {$speedPage := resolve-uri(extract(., 'url: *"([^"]+)"', 1)) || "?databaseId=" || extract(., 'databaseId: "([0-9]+)"', 1)  }
    </script>
    
  </form>
  
  <div class="alert message-error">{vl:raise(.)}</div> <!-- for debugging -->
  
  
  
</template:switch-prioritized>
